{
  "id": "8",
  "title": "Security Best Practices for Web Applications",
  "slug": "security-best-practices-web-applications",
  "excerpt": "Essential security measures every developer should implement to protect their web applications.",
  "coverImage": "https://images.unsplash.com/photo-1563986768609-322da13575f3?w=800&h=600&fit=crop",
  "publishedAt": "2024-07-18",
  "readTime": "13 min read",
  "category": "Security",
  "tags": ["Security", "Web Development", "Best Practices"],
  "author": "Alex Morgan",
  "featured": true,
  "content": "# Security Best Practices for Web Applications\n\nSecurity should be a top priority in web development. Let's cover the most important security practices every developer should implement.\n\n## OWASP Top 10\n\nThe Open Web Application Security Project (OWASP) maintains a list of the most critical security risks:\n\n1. Broken Access Control\n2. Cryptographic Failures\n3. Injection\n4. Insecure Design\n5. Security Misconfiguration\n6. Vulnerable Components\n7. Authentication Failures\n8. Software and Data Integrity Failures\n9. Security Logging and Monitoring Failures\n10. Server-Side Request Forgery (SSRF)\n\n## Authentication & Authorization\n\n### Secure Password Storage\n\n```javascript\nconst bcrypt = require('bcrypt');\n\n// Hash password\nasync function hashPassword(password) {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n}\n\n// Verify password\nasync function verifyPassword(password, hash) {\n  return await bcrypt.compare(password, hash);\n}\n```\n\n### JWT Implementation\n\n```javascript\nconst jwt = require('jsonwebtoken');\n\n// Generate token\nfunction generateToken(user) {\n  return jwt.sign(\n    { userId: user.id, email: user.email },\n    process.env.JWT_SECRET,\n    { expiresIn: '1h' }\n  );\n}\n\n// Verify token\nfunction verifyToken(token) {\n  try {\n    return jwt.verify(token, process.env.JWT_SECRET);\n  } catch (err) {\n    throw new Error('Invalid token');\n  }\n}\n\n// Middleware\nfunction authenticate(req, res, next) {\n  const token = req.headers.authorization?.split(' ')[1];\n  \n  if (!token) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  try {\n    req.user = verifyToken(token);\n    next();\n  } catch (err) {\n    res.status(401).json({ error: 'Invalid token' });\n  }\n}\n```\n\n### Role-Based Access Control\n\n```javascript\nfunction authorize(...roles) {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({ error: 'Unauthorized' });\n    }\n    \n    if (!roles.includes(req.user.role)) {\n      return res.status(403).json({ error: 'Forbidden' });\n    }\n    \n    next();\n  };\n}\n\n// Usage\napp.delete('/api/users/:id', \n  authenticate, \n  authorize('admin'), \n  deleteUser\n);\n```\n\n## Input Validation & Sanitization\n\n### SQL Injection Prevention\n\n```javascript\n// ❌ Vulnerable to SQL injection\nconst query = `SELECT * FROM users WHERE email = '${email}'`;\n\n// ✅ Use parameterized queries\nconst query = 'SELECT * FROM users WHERE email = $1';\nconst result = await db.query(query, [email]);\n\n// ✅ Use ORM\nconst user = await User.findOne({ where: { email } });\n```\n\n### XSS Prevention\n\n```javascript\nconst DOMPurify = require('isomorphic-dompurify');\n\n// Sanitize HTML input\nfunction sanitizeHtml(dirty) {\n  return DOMPurify.sanitize(dirty, {\n    ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],\n    ALLOWED_ATTR: ['href']\n  });\n}\n\n// Escape output in templates\n// React does this automatically\n<div>{userInput}</div> // Safe in React\n\n// In vanilla JS, use textContent\nelement.textContent = userInput; // Safe\nelement.innerHTML = userInput; // Dangerous!\n```\n\n### Input Validation with Zod\n\n```typescript\nimport { z } from 'zod';\n\nconst userSchema = z.object({\n  email: z.string().email(),\n  password: z.string().min(8).max(100),\n  age: z.number().int().min(18).max(120),\n  website: z.string().url().optional()\n});\n\napp.post('/api/users', async (req, res) => {\n  try {\n    const validated = userSchema.parse(req.body);\n    // Process validated data\n  } catch (err) {\n    res.status(400).json({ error: err.errors });\n  }\n});\n```\n\n## CSRF Protection\n\n```javascript\nconst csrf = require('csurf');\nconst cookieParser = require('cookie-parser');\n\napp.use(cookieParser());\napp.use(csrf({ cookie: true }));\n\n// Send token to client\napp.get('/api/csrf-token', (req, res) => {\n  res.json({ csrfToken: req.csrfToken() });\n});\n\n// Verify token on state-changing requests\napp.post('/api/data', (req, res) => {\n  // CSRF token automatically verified\n  // Process request\n});\n```\n\n## CORS Configuration\n\n```javascript\nconst cors = require('cors');\n\n// ❌ Don't allow all origins in production\napp.use(cors({ origin: '*' }));\n\n// ✅ Whitelist specific origins\nconst allowedOrigins = [\n  'https://myapp.com',\n  'https://www.myapp.com'\n];\n\napp.use(cors({\n  origin: (origin, callback) => {\n    if (!origin || allowedOrigins.includes(origin)) {\n      callback(null, true);\n    } else {\n      callback(new Error('Not allowed by CORS'));\n    }\n  },\n  credentials: true,\n  maxAge: 86400\n}));\n```\n\n## Rate Limiting\n\n```javascript\nconst rateLimit = require('express-rate-limit');\n\n// General rate limit\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // Limit each IP to 100 requests per windowMs\n  message: 'Too many requests, please try again later'\n});\n\napp.use('/api/', limiter);\n\n// Stricter limit for auth endpoints\nconst authLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5,\n  skipSuccessfulRequests: true\n});\n\napp.use('/api/auth/', authLimiter);\n```\n\n## Security Headers\n\n```javascript\nconst helmet = require('helmet');\n\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"]\n    }\n  },\n  hsts: {\n    maxAge: 31536000,\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n```\n\n## Secure File Uploads\n\n```javascript\nconst multer = require('multer');\nconst path = require('path');\n\nconst storage = multer.diskStorage({\n  destination: './uploads/',\n  filename: (req, file, cb) => {\n    // Generate unique filename\n    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n    cb(null, uniqueSuffix + path.extname(file.originalname));\n  }\n});\n\nconst upload = multer({\n  storage,\n  limits: {\n    fileSize: 5 * 1024 * 1024 // 5MB\n  },\n  fileFilter: (req, file, cb) => {\n    // Allow only specific file types\n    const allowedTypes = /jpeg|jpg|png|pdf/;\n    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\n    const mimetype = allowedTypes.test(file.mimetype);\n    \n    if (extname && mimetype) {\n      cb(null, true);\n    } else {\n      cb(new Error('Invalid file type'));\n    }\n  }\n});\n```\n\n## Environment Variables\n\n```javascript\n// .env file (never commit this!)\nDATABASE_URL=postgresql://user:pass@localhost:5432/db\nJWT_SECRET=your-secret-key-here\nAPI_KEY=your-api-key\n\n// Load environment variables\nrequire('dotenv').config();\n\n// Access securely\nconst dbUrl = process.env.DATABASE_URL;\n\n// ❌ Never expose secrets in client code\n// ❌ Never commit .env files\n// ✅ Use .env.example for documentation\n```\n\n## Logging & Monitoring\n\n```javascript\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.json(),\n  transports: [\n    new winston.transports.File({ filename: 'error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'combined.log' })\n  ]\n});\n\n// Log security events\napp.post('/api/login', async (req, res) => {\n  try {\n    const user = await authenticate(req.body);\n    logger.info('Successful login', { userId: user.id, ip: req.ip });\n    res.json({ user });\n  } catch (err) {\n    logger.warn('Failed login attempt', { \n      email: req.body.email, \n      ip: req.ip \n    });\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\n```\n\n## Dependency Security\n\n```bash\n# Audit dependencies\nnpm audit\n\n# Fix vulnerabilities\nnpm audit fix\n\n# Check for outdated packages\nnpm outdated\n\n# Use Snyk for continuous monitoring\nnpx snyk test\n```\n\n## API Security Checklist\n\n- ✅ Use HTTPS everywhere\n- ✅ Implement authentication & authorization\n- ✅ Validate and sanitize all inputs\n- ✅ Use parameterized queries\n- ✅ Implement rate limiting\n- ✅ Set security headers\n- ✅ Enable CORS properly\n- ✅ Implement CSRF protection\n- ✅ Hash passwords with bcrypt\n- ✅ Use JWT with expiration\n- ✅ Log security events\n- ✅ Keep dependencies updated\n- ✅ Use environment variables for secrets\n- ✅ Implement proper error handling\n- ✅ Regular security audits\n\n## Conclusion\n\nSecurity is not a one-time task but an ongoing process. Stay informed about new vulnerabilities, keep dependencies updated, and always follow security best practices. Remember: it's easier to build security in from the start than to add it later.\n\n## Resources\n\n- [OWASP Top 10](https://owasp.org/www-project-top-ten/)\n- [MDN Web Security](https://developer.mozilla.org/en-US/docs/Web/Security)\n- [Node.js Security Best Practices](https://nodejs.org/en/docs/guides/security/)\n- [Snyk Vulnerability Database](https://snyk.io/vuln/)\n"
}
