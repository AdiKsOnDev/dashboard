{
  "id": "1771440238111",
  "title": "Commit, Committed, or was Committed?",
  "slug": "commit-committed-or-was-committed",
  "excerpt": "All the ways I have written my commits and the compromises I found",
  "coverImage": "https://i.ibb.co/Ng5T3ZFG/Slide-16-9-4.png",
  "publishedAt": "2026-02-18",
  "readTime": "4 min read",
  "category": "Development",
  "tags": [
    "Git",
    "Automation",
    "Version Control"
  ],
  "author": "Adil Alizada",
  "featured": false,
  "content": "## What are commit messages for?\n\nCommits are developers' way to communicate and record the evolution of a project\nin a way that's convenient to both the end users and the contributors.\nAs you likely know, commits are accompanied with messages. The impact of these messages (when used appropriately) \nis vast, and most of it boils down to answering the question \"What changed?\". \nIdeally, you should be able to re-build a similar project based solely on the commit history.\nFortunately, Git does not enforce specific rules for these messages, so developers\nget the liberty to make up these rules in a way they see fit.\n\n## What are Conventional Commits?\n\nA common example of such specifications is [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/#specification). While the specifics of Conventional Commits are \noutside of the scope of this post, the main idea behind them is to divide commits into specific types and scopes\nwith the purpose of standardizing them and developing automation tools that allow for less overhead during version control.\nFurthermore, Conventional Commits encourage the developer to make more granular contributions which results in \na more detailed commit history. I will share some specific examples in the next section.\n\n## How do different teams approach writing commits?\n\nEach team develops a Git etiquette unique to them. Some follow Conventional Commits, some \nhave their own ruleset, others do not care. However, every team chooses how to phrase their commits, whether they know it or not.\n\nThree common options are:\n\n- *Past tense + Active voice*\n    >\"feat(profile): added cache invalidation\"\n- *Imperative + Active voice*\n    >\"feat(profile): add cache invalidation\"\n- *Passive voice*\n    >\"feat(profile): cache invalidation was added\"\n\nWhile each approach has its place, most developers gravitate toward the first two options; those are the ones we will focus on. \nThroughout my projects, I've bounced back and forth between these (seldom by choice). \nThe trade-offs I observed were apparent and caused me quite the internal battle around this decision. \n\n### Past + Active\nWriting in the past tense is something people naturally do. It feels like communicating \"I did *xyz*\" rather than \"do *xyz*\" which to some might feel backwards.\nWhile this may be useful in tight teams where people work on different scopes, main benefit of this approach to me is the way these commits read. Because they're \nin the past tense, the log is practically like a [CHANGELOG](https://keepachangelog.com/en/1.1.0/). This lets developers automate the process of releasing an update with great quality changelogs, which\neliminates the overhead and provides useful release notes. However, I came across many sources online saying that this is not conventional and is not how commits \nare usually treated. A popular rule of thumb is that a commit message should fit nicely into the sentence:\n\n> \"When applied, this commit will _\"\n\nFurthermore, that's how Git's auto-generated commit messages are written. That being said, I found it generates less mental friction to write commits this way. But \nbeware that following this style might mostly be valid if you plan on using your commits for the automated changelog. Otherwise, it's likely better to follow the\nconventional approach\n\n### Imperative + Active\nSince writing commit messages in the Imperative mood is inline with how Git expects developers to commit it has become a widely \naccepted convention. This fact alone comes with several benefits; tools designed to work with commit messages are more likely to expect them to be imperative, \ndevelopers are used to reading commits in this manner, and I've observed some beginners commit this way naturally.\nMy issue is that I always automate releases using these messages. End users typically expect the CHANGELOG to read in a \"What changed?\" manner.\nCommit messages written in Imperative mood do not read that way. Because of this, I end up editing the release notes manually (though a pre-processor\nthat automatically re-writes the messages before appending them to the changelog would help with this).\nIt’s also worth noting that, when using agentic development systems (e.g., OpenCode, Claude Code), if you allow your agents to commit autonomously they \ntend to prefer this style unless prompted otherwise.\n\n## Further Resources\n- [Conventional Commits](https://www.conventionalcommits.org/) - the official specification and guidelines\n- [Semantic Versioning (SemVer)](https://semver.org/) - rules for version numbers and compatibility\n- [Keep a Changelog](https://keepachangelog.com/) - best‑practice format for human‑readable changelogs\n- [Commit‑lint](https://github.com/conventional-changelog/commitlint) - a configurable linter for enforcing Conventional Commits"
}
